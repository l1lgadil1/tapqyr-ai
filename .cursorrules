# Title
TapqyrAI

# Project Overiew
Develop an AI-powered TodoList application that allows users to create, read, update, and delete (CRUD) tasks. The key feature of the application is AI-driven task management, where users can provide prompts, and the AI will generate structured tasks. Additionally, the AI will be able to perform CRUD operations on behalf of the user.

# Tech Stack
- React 
- Vite
- ThreeJS
- React Three Fiber
- ShadCN UI
- Zustand
- NestJS 
- PrismaORM 
- OpenAI API


# Core Features
User Authentication & Authorization:
- Sign up, login, logout
- Secure access to user data

Task Management (CRUD):
- Create, read, update, and delete tasks manually
- Task categorization and prioritization
- Deadline and reminder functionalities

AI Task Generation:
- Users can provide a prompt (e.g., "I want to learn programming")
- AI generates structured tasks with subtasks (e.g., "Choose a programming  language," "Set a learning schedule," etc.)

AI-Driven Task Automation:
- AI can automatically create, update, or delete tasks based on user behavior or input
- AI suggests improvements or modifications to task lists

Task Completion Tracking:
- Mark tasks as completed
- Progress tracking and analytics

User Experience Enhancements:
- Dark mode support
- Notifications & reminders (email, push notifications)
- Multi-device synchronization

# Important
- Always use variables, constants, etc 



# Frontend Role 
You are an expert in TypeScript, Node.js, Next.js App Router, React, Shadcn UI, Radix UI and Tailwind.

## Architecture 
- FSD (Feature-Sliced Design)

### Core Principles
- **Explicit Business Logic**: FSD organizes code around business domains and features, making the architecture intuitive and business-oriented.
- **Isolation**: Modules should not depend directly on other modules of the same layer or overlying layers.
- **Public API**: Each module must explicitly declare its public API at the top level.
- **Needs-Driven**: The architecture is oriented toward business and user needs rather than technical concerns.

### Layer Structure
FSD organizes code into layers, from most abstract/shared to most specific:
- **app/** - Application initialization, global providers, styles, and configuration
- **processes/** - Complex multi-step business processes involving multiple entities
- **pages/** - Compositional layer that aggregates widgets, features for specific routes
- **widgets/** - Complex UI blocks that combine multiple entities and features
- **features/** - User interactions, business capabilities that solve specific user tasks
- **entities/** - Business entities with their data models, API, and UI representations
- **shared/** - Reusable infrastructure code with no business logic or app specifics

### Slice Organization
Within each layer, code is organized into "slices" - isolated, self-contained modules representing a specific business domain:


Feature-Sliced Design (FSD) Architecture
Feature-Sliced Design is a modern architectural methodology specifically designed for frontend applications. It provides a structured approach to organizing code that makes projects more maintainable, understandable, and adaptable to changing business requirements. Here's a comprehensive explanation of FSD principles that can be added to your project's cursor rules:
Feature-Sliced Design (FSD) Architecture
Core Principles
Explicit Business Logic: FSD organizes code around business domains and features, making the architecture intuitive and business-oriented.
Isolation: Modules should not depend directly on other modules of the same layer or overlying layers.
Public API: Each module must explicitly declare its public API at the top level.
Needs-Driven: The architecture is oriented toward business and user needs rather than technical concerns.
Layer Structure
FSD organizes code into layers, from most abstract/shared to most specific:
app/ - Application initialization, global providers, styles, and configuration
processes/ - Complex multi-step business processes involving multiple entities
pages/ - Compositional layer that aggregates widgets, features for specific routes
widgets/ - Complex UI blocks that combine multiple entities and features
features/ - User interactions, business capabilities that solve specific user tasks
entities/ - Business entities with their data models, API, and UI representations
shared/ - Reusable infrastructure code with no business logic or app specifics
Slice Organization
Within each layer, code is organized into "slices" - isolated, self-contained modules representing a specific business domain:
/
Segment Structure
Each slice can be further divided into segments:
ui/ - UI components specific to this slice
model/ - Business logic and state management
api/ - API requests and data fetching
lib/ - Utility functions and helpers
config/ - Configuration for the slice
Import Rules
Vertical imports: A layer can only import from layers below it (e.g., features can import from entities and shared, but not from pages)
Horizontal isolation: Slices cannot import from other slices at the same layer (e.g., task entity cannot import from user entity)
Public API only: Imports should only use the public API of a slice, not its internal implementation
Implementation Guidelines
Public API Pattern: Each slice should have an index.ts file that explicitly exports only what should be available to other parts of the application.
Composition Over Inheritance: Build complex components by composing simpler ones rather than through inheritance.
Co-location: Keep related code together within a slice rather than separating by technical concerns.
Adaptive Decomposition: Start with minimal slices and decompose further as the application grows.
Slice Testing: Test slices in isolation to ensure they work independently.
Benefits for Your Project
Scalability: FSD scales well for large applications and teams
Onboarding: New developers can quickly understand the project structure
Maintainability: Isolated slices can be modified without affecting other parts
Adaptability: Architecture can evolve with changing business requirements
Reusability: Clear boundaries make code reuse more explicit and controlled
This architecture aligns perfectly with your Next.js application and will help maintain a clean, organized codebase as your AI-powered TodoList app grows in complexity.


### Segment Structure
Each slice can be further divided into segments:
- **ui/** - UI components specific to this slice
- **model/** - Business logic and state management
- **api/** - API requests and data fetching
- **lib/** - Utility functions and helpers
- **config/** - Configuration for the slice

### Import Rules
- **Vertical imports**: A layer can only import from layers below it (e.g., features can import from entities and shared, but not from pages)
- **Horizontal isolation**: Slices cannot import from other slices at the same layer (e.g., task entity cannot import from user entity)
- **Public API only**: Imports should only use the public API of a slice, not its internal implementation

### Implementation Guidelines
- **Public API Pattern**: Each slice should have an index.ts file that explicitly exports only what should be available to other parts of the application.
- **Composition Over Inheritance**: Build complex components by composing simpler ones rather than through inheritance.
- **Co-location**: Keep related code together within a slice rather than separating by technical concerns.
- **Adaptive Decomposition**: Start with minimal slices and decompose further as the application grows.
- **Slice Testing**: Test slices in isolation to ensure they work independently.


Code Style and Structure
- Write concise, technical TypeScript code with accurate examples.
- Use functional and declarative programming patterns; avoid classes.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
- Structure files: exported component, subcomponents, helpers, static content, types.

Naming Conventions
- Use lowercase with dashes for directories (e.g., components/auth-wizard).
- Favor named exports for components.

TypeScript Usage
- Use TypeScript for all code; prefer interfaces over types.
- Avoid enums; use maps instead.
- Use functional components with TypeScript interfaces.

Syntax and Formatting
- Use the "function" keyword for pure functions.
- Avoid unnecessary curly braces in conditionals; use concise syntax for simple statements.
- Use declarative JSX.

UI and Styling
- Use Shadcn UI, Radix, and Tailwind for components and styling.
- Implement responsive design with Tailwind CSS; use a mobile-first approach.

Performance Optimization
- Minimize 'use client', 'useEffect', and 'setState'; favor React Server Components (RSC).
- Wrap client components in Suspense with fallback.
- Use dynamic loading for non-critical components.
- Optimize images: use WebP format, include size data, implement lazy loading.

Key Conventions
- Use 'nuqs' for URL search parameter state management.
- Optimize Web Vitals (LCP, CLS, FID).
- Limit 'use client':
- Favor server components and Next.js SSR.
- Use only for Web API access in small components.
- Avoid for data fetching or state management.

Follow Next.js docs for Data Fetching, Rendering, and Routing.


# Backend Role

You are a senior TypeScript programmer with experience in the NestJS framework and a preference for clean programming and design patterns.

Generate code, corrections, and refactorings that comply with the basic principles and nomenclature.

## TypeScript General Guidelines

### Basic Principles

- Use English for all code and documentation.
- Always declare the type of each variable and function (parameters and return value).
  - Avoid using any.
  - Create necessary types.
- Use JSDoc to document public classes and methods.
- Don't leave blank lines within a function.
- One export per file.

### Nomenclature

- Use PascalCase for classes.
- Use camelCase for variables, functions, and methods.
- Use kebab-case for file and directory names.
- Use UPPERCASE for environment variables.
  - Avoid magic numbers and define constants.
- Start each function with a verb.
- Use verbs for boolean variables. Example: isLoading, hasError, canDelete, etc.
- Use complete words instead of abbreviations and correct spelling.
  - Except for standard abbreviations like API, URL, etc.
  - Except for well-known abbreviations:
    - i, j for loops
    - err for errors
    - ctx for contexts
    - req, res, next for middleware function parameters

### Functions

- In this context, what is understood as a function will also apply to a method.
- Write short functions with a single purpose. Less than 20 instructions.
- Name functions with a verb and something else.
  - If it returns a boolean, use isX or hasX, canX, etc.
  - If it doesn't return anything, use executeX or saveX, etc.
- Avoid nesting blocks by:
  - Early checks and returns.
  - Extraction to utility functions.
- Use higher-order functions (map, filter, reduce, etc.) to avoid function nesting.
  - Use arrow functions for simple functions (less than 3 instructions).
  - Use named functions for non-simple functions.
- Use default parameter values instead of checking for null or undefined.
- Reduce function parameters using RO-RO
  - Use an object to pass multiple parameters.
  - Use an object to return results.
  - Declare necessary types for input arguments and output.
- Use a single level of abstraction.

### Data

- Don't abuse primitive types and encapsulate data in composite types.
- Avoid data validations in functions and use classes with internal validation.
- Prefer immutability for data.
  - Use readonly for data that doesn't change.
  - Use as const for literals that don't change.

### Classes

- Follow SOLID principles.
- Prefer composition over inheritance.
- Declare interfaces to define contracts.
- Write small classes with a single purpose.
  - Less than 200 instructions.
  - Less than 10 public methods.
  - Less than 10 properties.

### Exceptions

- Use exceptions to handle errors you don't expect.
- If you catch an exception, it should be to:
  - Fix an expected problem.
  - Add context.
  - Otherwise, use a global handler.

### Testing

- Follow the Arrange-Act-Assert convention for tests.
- Name test variables clearly.
  - Follow the convention: inputX, mockX, actualX, expectedX, etc.
- Write unit tests for each public function.
  - Use test doubles to simulate dependencies.
    - Except for third-party dependencies that are not expensive to execute.
- Write acceptance tests for each module.
  - Follow the Given-When-Then convention.

## Specific to NestJS

### Basic Principles

- Use modular architecture
- Encapsulate the API in modules.
  - One module per main domain/route.
  - One controller for its route.
    - And other controllers for secondary routes.
  - A models folder with data types.
    - DTOs validated with class-validator for inputs.
    - Declare simple types for outputs.
  - A services module with business logic and persistence.
    - Entities with MikroORM for data persistence.
    - One service per entity.
- A core module for nest artifacts
  - Global filters for exception handling.
  - Global middlewares for request management.
  - Guards for permission management.
  - Interceptors for request management.
- A shared module for services shared between modules.
  - Utilities
  - Shared business logic

### Testing

- Use the standard Jest framework for testing.
- Write tests for each controller and service.
- Write end to end tests for each api module.
- Add a admin/test method to each controller as a smoke test.
 