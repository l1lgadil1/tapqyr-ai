import { v4 as uuidv4 } from 'uuid';
import { Todo, CreateTodoDto, UpdateTodoDto, GetTodosOptions } from '../types/todo';
import logger from '../utils/logger';
import prisma from '../utils/prisma';

/**
 * Service for managing todo items using Prisma for persistence
 */
export class TodoService {
  /**
   * Convert Prisma Todo to application Todo
   */
  private convertPrismaTodoToAppTodo(prismaTodo: any): Todo {
    return {
      id: prismaTodo.id,
      title: prismaTodo.title,
      description: prismaTodo.description,
      completed: prismaTodo.completed,
      dueDate: prismaTodo.dueDate,
      priority: prismaTodo.priority as 'low' | 'medium' | 'high',
      createdAt: prismaTodo.createdAt,
      userId: prismaTodo.userId,
      isAutoGenerated: prismaTodo.isAIGenerated || false
    };
  }

  /**
   * Get all todos with pagination, filtering, and sorting
   */
  public async getAllTodos(options: GetTodosOptions = {}): Promise<{ todos: Todo[]; total: number }> {
    try {
      const { 
        sortBy = 'newest', 
        offset = 0, 
        limit = 100,
        search = '',
        priority = '',
        status = '',
        autoFilter = false,
        dateFilter = '',
        dateRangeStart = '',
        dateRangeEnd = ''
      } = options;
      
      // Build where clause for filtering
      const where: any = {};
      
      // Add priority filter if provided
      if (priority && priority !== 'all' && ['low', 'medium', 'high'].includes(priority)) {
        where.priority = priority;
      }
      
      // Add status filter if provided
      if (status && status !== 'all') {
        if (status === 'completed') {
          where.completed = true;
        } else if (status === 'active') {
          where.completed = false;
        }
      }

      // Add auto-generated filter if provided
      if (autoFilter) {
        where.isAIGenerated = true;
      }
      
      // Add search filter if provided
      if (search && search.trim() !== '') {
        // Don't lowercase the search term since SQLite's comparison might be case-sensitive
        // for non-ASCII characters like Cyrillic
        const searchTerm = search.trim();
        
        // Use a more flexible search approach with multiple conditions
        where.OR = [
          // Case sensitive exact match
          { title: { contains: searchTerm } },
          { description: { contains: searchTerm } },
          // Lowercase match
          { title: { contains: searchTerm.toLowerCase() } },
          { description: { contains: searchTerm.toLowerCase() } },
          // Uppercase match
          { title: { contains: searchTerm.toUpperCase() } },
          { description: { contains: searchTerm.toUpperCase() } }
        ];
      }
      
      // Add date filter if provided (exact date)
      if (dateFilter && dateFilter.trim() !== '') {
        try {
          // Parse the date string (YYYY-MM-DD)
          const filterDate = new Date(dateFilter);
          filterDate.setHours(0, 0, 0, 0);
          
          // Create the next day for range comparison
          const nextDay = new Date(filterDate);
          nextDay.setDate(nextDay.getDate() + 1);
          
          // Filter todos due on this specific date
          where.dueDate = {
            gte: filterDate,
            lt: nextDay
          };
        } catch (err) {
          logger.warn(`Invalid date filter format: ${dateFilter}. Expected YYYY-MM-DD.`);
          // If date parsing fails, ignore the filter
        }
      }
      // Add date range filter if both start and end dates are provided
      else if (dateRangeStart && dateRangeEnd) {
        try {
          // Parse the start date string (YYYY-MM-DD)
          const startDate = new Date(dateRangeStart);
          startDate.setHours(0, 0, 0, 0);
          
          // Parse the end date string (YYYY-MM-DD)
          const endDate = new Date(dateRangeEnd);
          endDate.setHours(0, 0, 0, 0);
          
          // Add one day to end date to include the full end date
          const inclusiveEndDate = new Date(endDate);
          inclusiveEndDate.setDate(inclusiveEndDate.getDate() + 1);
          
          // Filter todos due within this date range
          where.dueDate = {
            gte: startDate,
            lt: inclusiveEndDate
          };
        } catch (err) {
          logger.warn(`Invalid date range format. Expected YYYY-MM-DD.`);
          // If date parsing fails, ignore the filter
        }
      }
      // If only start date is provided
      else if (dateRangeStart) {
        try {
          // Parse the start date string (YYYY-MM-DD)
          const startDate = new Date(dateRangeStart);
          startDate.setHours(0, 0, 0, 0);
          
          // Filter todos due on or after this date
          where.dueDate = {
            gte: startDate
          };
        } catch (err) {
          logger.warn(`Invalid start date format: ${dateRangeStart}. Expected YYYY-MM-DD.`);
        }
      }
      // If only end date is provided
      else if (dateRangeEnd) {
        try {
          // Parse the end date string (YYYY-MM-DD)
          const endDate = new Date(dateRangeEnd);
          endDate.setHours(0, 0, 0, 0);
          
          // Add one day to include the full end date
          const inclusiveEndDate = new Date(endDate);
          inclusiveEndDate.setDate(inclusiveEndDate.getDate() + 1);
          
          // Filter todos due before this date
          where.dueDate = {
            lt: inclusiveEndDate
          };
        } catch (err) {
          logger.warn(`Invalid end date format: ${dateRangeEnd}. Expected YYYY-MM-DD.`);
        }
      }
      
      // Determine sort order
      let orderBy: any = { createdAt: 'desc' }; // Default sorting (newest)
      
      // Apply sorting based on the sortBy parameter
      switch (sortBy) {
        case 'oldest':
          orderBy = { createdAt: 'asc' };
          break;
        case 'priority':
          // For priority sorting, we'll fetch all results first and sort them in JavaScript
          // since Prisma with SQLite doesn't support custom sort order directly
          orderBy = { createdAt: 'desc' }; // Default secondary sort
          break;
        case 'dueDate':
          orderBy = [
            { dueDate: 'asc', nulls: 'last' },
            { createdAt: 'desc' }
          ];
          break;
        case 'newest':
        default:
          orderBy = { createdAt: 'desc' };
          break;
      }
      
      // Get total count
      const total = await prisma.todo.count({ where });
      
      // Fetch todos with pagination
      const todos = await prisma.todo.findMany({
        where,
        orderBy,
        skip: offset,
        take: limit
      });
      
      // Convert Prisma todos to app todos
      let appTodos = todos.map(todo => this.convertPrismaTodoToAppTodo(todo));
      
      // Apply custom priority sorting in JavaScript if needed
      if (sortBy === 'priority') {
        const priorityOrder = { 'high': 0, 'medium': 1, 'low': 2, null: 3, undefined: 3 };
        appTodos = appTodos.sort((a, b) => {
          // First sort by priority (high to low)
          const priorityA = priorityOrder[a.priority] ?? 3;
          const priorityB = priorityOrder[b.priority] ?? 3;
          
          if (priorityA !== priorityB) {
            return priorityA - priorityB;
          }
          
          // Then by created date (newest first) for same priority
          return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
        });
      }
      
      return { todos: appTodos, total };
    } catch (error) {
      logger.error(`Error getting todos: ${(error as Error).message}`);
      throw new Error(`Failed to get todos: ${(error as Error).message}`);
    }
  }

  /**
   * Get a todo by ID
   */
  public async getTodoById(id: string): Promise<Todo | null> {
    try {
      const todo = await prisma.todo.findUnique({
        where: { id }
      });
      
      if (!todo) {
        return null;
      }
      
      return this.convertPrismaTodoToAppTodo(todo);
    } catch (error) {
      logger.error(`Error getting todo by ID ${id}: ${(error as Error).message}`);
      throw new Error(`Failed to get todo: ${(error as Error).message}`);
    }
  }

  /**
   * Create a new todo
   */
  public async createTodo(todoDto: CreateTodoDto): Promise<Todo> {
    try {
      // Validate priority
      const priority = todoDto.priority || 'medium';
      if (!['low', 'medium', 'high'].includes(priority)) {
        throw new Error(`Invalid priority: ${priority}`);
      }
      
      const newTodo = await prisma.todo.create({
        data: {
          id: uuidv4(),
          title: todoDto.title,
          description: todoDto.description,
          completed: todoDto.completed ?? false,
          priority: priority,
          dueDate: todoDto.dueDate ? new Date(todoDto.dueDate) : null,
          isAIGenerated: todoDto.isAutoGenerated ?? false
        }
      });
      
      return this.convertPrismaTodoToAppTodo(newTodo);
    } catch (error) {
      logger.error(`Error creating todo: ${(error as Error).message}`);
      throw new Error(`Failed to create todo: ${(error as Error).message}`);
    }
  }

  /**
   * Update an existing todo
   */
  public async updateTodo(id: string, todoDto: UpdateTodoDto): Promise<Todo | null> {
    try {
      // First check if the todo exists
      const existingTodo = await this.getTodoById(id);
      if (!existingTodo) {
        return null;
      }
      
      // Validate priority if provided
      if (todoDto.priority && !['low', 'medium', 'high'].includes(todoDto.priority)) {
        throw new Error(`Invalid priority: ${todoDto.priority}`);
      }
      
      // Handle dueDate conversion safely
      let dueDate = undefined;
      if (todoDto.dueDate !== undefined) {
        dueDate = todoDto.dueDate ? new Date(todoDto.dueDate) : null;
      }

      const updatedTodo = await prisma.todo.update({
        where: { id },
        data: {
          title: todoDto.title !== undefined ? todoDto.title : undefined,
          description: todoDto.description !== undefined ? todoDto.description : undefined,
          completed: todoDto.completed !== undefined ? todoDto.completed : undefined,
          priority: todoDto.priority !== undefined ? todoDto.priority : undefined,
          dueDate: dueDate
        }
      });
      
      return this.convertPrismaTodoToAppTodo(updatedTodo);
    } catch (error) {
      logger.error(`Error updating todo ${id}: ${(error as Error).message}`);
      throw new Error(`Failed to update todo: ${(error as Error).message}`);
    }
  }

  /**
   * Delete a todo by ID
   */
  public async deleteTodo(id: string): Promise<boolean> {
    try {
      // First check if the todo exists
      const existingTodo = await this.getTodoById(id);
      if (!existingTodo) {
        return false;
      }

      await prisma.todo.delete({
        where: { id }
      });
      return true;
    } catch (error) {
      logger.error(`Error deleting todo ${id}: ${(error as Error).message}`);
      throw new Error(`Failed to delete todo: ${(error as Error).message}`);
    }
  }

  /**
   * Toggle todo completion status
   */
  public async toggleTodoCompletion(id: string): Promise<Todo | null> {
    try {
      const todo = await this.getTodoById(id);
      if (!todo) {
        return null;
      }

      const updatedTodo = await prisma.todo.update({
        where: { id },
        data: { completed: !todo.completed }
      });
      
      return this.convertPrismaTodoToAppTodo(updatedTodo);
    } catch (error) {
      logger.error(`Error toggling todo completion ${id}: ${(error as Error).message}`);
      throw new Error(`Failed to toggle todo completion: ${(error as Error).message}`);
    }
  }

  /**
   * Generate todos based on user prompt using OpenAI
   */
  public async generateTodos(prompt: string): Promise<Todo[]> {
    logger.info(`Generating todos with OpenAI for prompt: ${prompt}`);
    
    try {
      // Import OpenAI
      const OpenAI = require('openai');
      
      // Initialize OpenAI client
      const openai = new OpenAI({
        apiKey: process.env.OPENAI_API_KEY,
      });
      
      // Create a system message to instruct the model
      const systemMessage = `
        You are a helpful task management assistant. 
        Generate a list of well-structured, actionable tasks based on the user's goal or request.
        For each task, provide:
        1. A clear, concise title
        2. A brief description with details
        3. A suggested priority (low, medium, high)
        4. A suggested due date (relative to today)
        
        Format your response as a JSON array of task objects with the following structure:
        [
          {
            "title": "Task title",
            "description": "Task description",
            "priority": "low|medium|high",
            "dueDate": "YYYY-MM-DD"
          }
        ]
      `;
      
      // Call OpenAI API
      const response = await openai.chat.completions.create({
        model: "gpt-3.5-turbo",
        messages: [
          { role: "system", content: systemMessage },
          { role: "user", content: prompt }
        ],
        temperature: 0.7,
        max_tokens: 1000,
        response_format: { type: "json_object" }
      });
      
      // Parse the response
      const content = response.choices[0].message.content;
      const parsedResponse = JSON.parse(content);
      
      if (!parsedResponse.tasks || !Array.isArray(parsedResponse.tasks)) {
        throw new Error('Invalid response format from OpenAI');
      }
      
      // Convert OpenAI response to Todo objects
      const todos: Todo[] = [];
      
      for (const task of parsedResponse.tasks) {
        const todo: CreateTodoDto = {
          title: task.title,
          description: task.description || "",
          completed: false,
          dueDate: task.dueDate ? new Date(task.dueDate).toISOString() : new Date().toISOString(),
          priority: task.priority || "medium",
          isAutoGenerated: true
        };
        
        const createdTodo = await this.createTodo(todo);
        todos.push(createdTodo);
      }
      
      return todos;
    } catch (error) {
      logger.error(`Error generating todos with OpenAI: ${(error as Error).message}`);
      
      // Fallback to creating a simple todo
      const defaultTodo: CreateTodoDto = {
        title: prompt,
        description: "Manually created todo",
        completed: false,
        dueDate: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(), // Tomorrow as ISO string
        priority: "medium",
        isAutoGenerated: false
      };
      
      const todo = await this.createTodo(defaultTodo);
      return [todo];
    }
  }

  /**
   * Get todos due today
   */
  public async getTodayTodos(): Promise<{ todos: Todo[]; total: number }> {
    try {
      // Get today's date range (start of day to end of day)
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      
      // Query todos due today
      const todos = await prisma.todo.findMany({
        where: {
          dueDate: {
            gte: today,
            lt: tomorrow
          }
        },
        orderBy: [
          { priority: 'desc' }, // High priority first
          { createdAt: 'desc' }
        ]
      });
      
      // Convert Prisma todos to app todos
      const appTodos = todos.map(todo => this.convertPrismaTodoToAppTodo(todo));
      
      return { todos: appTodos, total: appTodos.length };
    } catch (error) {
      logger.error(`Error getting today's todos: ${(error as Error).message}`);
      throw new Error(`Failed to get today's todos: ${(error as Error).message}`);
    }
  }

  /**
   * Get upcoming todos (due in the next 7 days, excluding today)
   */
  public async getUpcomingTodos(): Promise<{ todos: Todo[]; total: number }> {
    try {
      // Get date range (tomorrow to 7 days from now)
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      
      const sevenDaysLater = new Date(today);
      sevenDaysLater.setDate(sevenDaysLater.getDate() + 8); // +8 to include the 7th day fully
      
      // Query upcoming todos
      const todos = await prisma.todo.findMany({
        where: {
          dueDate: {
            gte: tomorrow,
            lt: sevenDaysLater
          }
        },
        orderBy: [
          { dueDate: 'asc' },
          { priority: 'desc' }, // High priority first
          { createdAt: 'desc' }
        ]
      });
      
      // Convert Prisma todos to app todos
      const appTodos = todos.map(todo => this.convertPrismaTodoToAppTodo(todo));
      
      return { todos: appTodos, total: appTodos.length };
    } catch (error) {
      logger.error(`Error getting upcoming todos: ${(error as Error).message}`);
      throw new Error(`Failed to get upcoming todos: ${(error as Error).message}`);
    }
  }

  /**
   * Get dashboard statistics
   */
  public async getDashboardStats(): Promise<{
    totalTodos: number;
    completedTodos: number;
    activeTodos: number;
    todayTodos: number;
    upcomingTodos: number;
    highPriorityTodos: number;
    completionRate: number;
  }> {
    try {
      // Get total count
      const totalTodos = await prisma.todo.count();
      
      // Get completed count
      const completedTodos = await prisma.todo.count({
        where: { completed: true }
      });
      
      // Calculate active todos
      const activeTodos = totalTodos - completedTodos;
      
      // Get today's date range
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      
      // Get upcoming date range (next 7 days excluding today)
      const sevenDaysLater = new Date(today);
      sevenDaysLater.setDate(sevenDaysLater.getDate() + 8);
      
      // Get today's todos count
      const todayTodos = await prisma.todo.count({
        where: {
          dueDate: {
            gte: today,
            lt: tomorrow
          }
        }
      });
      
      // Get upcoming todos count
      const upcomingTodos = await prisma.todo.count({
        where: {
          dueDate: {
            gte: tomorrow,
            lt: sevenDaysLater
          }
        }
      });
      
      // Get high priority todos count
      const highPriorityTodos = await prisma.todo.count({
        where: {
          priority: 'high',
          completed: false
        }
      });
      
      // Calculate completion rate
      const completionRate = totalTodos > 0 
        ? Math.round((completedTodos / totalTodos) * 100) 
        : 0;
      
      return {
        totalTodos,
        completedTodos,
        activeTodos,
        todayTodos,
        upcomingTodos,
        highPriorityTodos,
        completionRate
      };
    } catch (error) {
      logger.error(`Error getting dashboard stats: ${(error as Error).message}`);
      throw new Error(`Failed to get dashboard stats: ${(error as Error).message}`);
    }
  }
} 